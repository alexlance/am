#!/bin/bash

# Global vars
REDB='\033[1;31m'
REDBU='\033[1;4;31m'
GREEN='\033[1;36m'
NC='\033[0m'
BOLD='\033[1m'

# Help message
aws_usage="
${REDBU}NAME${NC}
      ${BOLD}bam${NC} - DEATH TO THE AWS CONSOLE!!!

${REDBU}SYNOPSIS${NC}
        bam [options...] <parameters>

      Use the bam command so you dont have to remember all the stupid aws 
      cli parameters to get basic information about instances and go through all
      the man pages, there is so much. Hopefully this makes your life a little 
      easier.

      All the following searches will add wildcards on either side of the string
      implicitly, for example: ${REDB}bam -a *instancename*${NC}

      There is no need to add the wildcard yourself this is already done within
      the application. This was just to show how the search is really done.

${REDBU}OPTIONS${NC}
      ${REDB}-i, --instance-ip${NC} <instance-name>
          Show the ip addresses of the instance you search for. The private ip
          will be shown by default.

      ${REDB}-I, --instance-info${NC} <instance-name>
          Provide the following information of the instance you have specified:

            o AvailabilityZone
            o PrivateIpAddress
            o InstanceId
            o Name 

      ${REDB}-t, --instance-type${NC} <instance-type>
          Optionally provide an instance type to narrow down searches further.
          By default if this option isn't selected it will just search all
          instance types.

      ${REDB}-a, --asg-count${NC} <asg-name>
          Get the current instance count of an auto-scaling group.

      ${REDB}-A, --asg-info${NC} <asg-name>
          Provide the following information of an auto-scaling group:

            o AvailabilityZone
            o HealthStatus
            o InstanceId
            o State

      ${REDB}-b, --s3-size${NC} <bucket-name>
          Retrieve the bucket size of specified bucket name.

      ${REDB}-s, --ssh${NC} <instance-name>
          Provide a list of options that are returned from the instance name
          searched. You then select the number of the instance you would like to
          SSH to.

      ${REDB}-S, --scp${NC} <instance-name> -S <source> [-S <target>]
          Provide a list of options that are returned from the instance name
          searched. You then select the number of the instance you would like to
          to SCP files across to, please note you still need correct permissions
          and SSH keys to authorise correctly. Target will default to your home
          directory on the remote server, so only specify for other directories.

      ${REDB}-o, --output${NC} <style>
          Formatting style for output:

            o json (default)
            o text
            o table

      ${REDB}-h, --help${NC}
          Display help, duh....can't believe this is even required."

# aws functions - the titles speak for themselves
function get_instance_ips () {
  aws ec2 describe-instances \
  --filters "Name=tag:Name,Values=*${1}*" "Name=instance-state-code,Values=16" \
  --query 'Reservations[].Instances[].[ PrivateIpAddress ]' --output ${2}
}

function get_instance_info () {
  aws ec2 describe-instances \
  --filters "Name=tag:Name,Values=*${1}*" "Name=instance-state-code,Values=16" \
  "Name=instance-type,Values=${3}" \
  --query "Reservations[*].Instances[*].{Name:Tags[?Key=='Name'] \
  | [0].Value, InstanceId: InstanceId, IP: PrivateIpAddress, \
  InstanceType:InstanceType, AZ: Placement.AvailabilityZone}" \
  --output ${2}
}

function get_asg_name () {
  aws autoscaling describe-auto-scaling-groups --query \
  'AutoScalingGroups[].{ASG:AutoScalingGroupName}' \
  --output text | grep ${1}
}

function get_asg_info () {
  aws autoscaling describe-auto-scaling-groups --auto-scaling-group-name \
  "$(get_asg_name ${1})" --query "AutoScalingGroups[].Instances[]. \
  {InstanceId:InstanceId,Health:HealthStatus,State:LifecycleState,AZ:AvailabilityZone}" \
  --output  
}

function get_bucket_size () {
  now=$(date +%s)
  aws cloudwatch get-metric-statistics --namespace "AWS/S3" \
  --start-time "$(echo "${now} - 86400" | bc)" --end-time "${now}" \
  --metric-name BucketSizeBytes --period 86400 --statistics Sum --unit Bytes \
  --dimensions Name=BucketName,Value=${1} Name=StorageType,Value=StandardStorage \
  --output ${2}
}

# get the longest string in array and print out length.
function element_length () {
  local array=$1
  array=($@)

  longest=""
  for element in ${array[@]}; do
    if [ ${#element} -gt ${#longest} ]; then
      longest=${element}
    fi
  done

  echo "${#longest}"
}

# create menu with options to select from
function create_menu () {
  if [ ${#name_array} -eq 0 ]; then
    echo -e "${REDB}No servers found, exiting...better luck next time...${NC}"
    exit 1;
  else
    # add total lengths of name tag and ip addresses.
    pretty_title
    pretty_table

    # titles
    printf "| ${BOLD}%-5s${NC}| ${BOLD}%-${name_len}s${NC} | ${BOLD}%-${ip_len}s${NC} |\n" "No." "Servers" "IP Address"
    pretty_table

    # print out instance information
    for ((i=1; i<=${#name_array[@]}; i++)); do
        printf "| ${BOLD}%-5s${NC}| ${BOLD}%-${name_len}s${NC} | ${BOLD}%-${ip_len}s${NC} |\n" "$i" "${name_array[$i-1]}" "${ip_array[$i-1]}"
    done

    pretty_table
    printf "\n"
  fi
}

function pretty_title () {
  total_len=$((${name_len} + ${ip_len} + 9))
  half_len=$((total_len/2))
  for ((i=1; i<=$((${total_len}+5)); i++)); do
    printf "-"
  done
  printf "\n"
  printf "| ${REDB}%$((${half_len}-1))s${NC} %$((${half_len}+1))s |\n" "${SSHSCP}" ""
}

function pretty_table () {
  printf "+"
  for ((i=1; i<=6; i++)); do
    printf "-"
  done
  printf "+"

  for ((i=1; i<=$((${name_len}+2)); i++)); do
    printf "-"
  done
  printf "+"

  for ((i=1; i<=$((${ip_len}+2)); i++)); do
    printf "-"
  done
  printf "+\n"
}

# ssh or scp over to selected servers
function select_ssh_scp () {
  create_menu

  while true; do
    prompt="Enter the No. of the instance you would like to SSH/SCP or type 0 or <CTRL+C> to quit: "
    read -rp "${prompt}" num
    case "${num}" in
      "" | *[!.0-9]* ) # need to figure out a way to put integer range from 1 - ${#name_array}
        echo -e "${REDB}Please only select from available options!${NC}"
        ;;
      0)
        echo -e "Exiting..."
        exit 0
        ;;
      *)
        clear
        break
        ;;
    esac
  done

  num=$((num-1)) # subtract number, because element in array starts at 0
  printf "Connecting to...${GREEN}${ip_array[num]}${NC}\n\n"

  # SSH or SCP mode depending on flag enabled
  if [ "${s}" ]; then
    ssh -A "${ip_array[num]}"
  elif [ "${S}" ]; then
    scp "${3}" "${ip_array[num]}":"${4:-}"
  fi
}

# checks for empty arguments
function empty_args () {
    local ARG=$1
    local OPT=$2

    [[ -z "${ARG}" || "${ARG}" =~ ^[[:space:]]*$ || "${ARG}" == -* ]] \
    && { empty_message "${OPT}" >&2; exit 1; }
}

function empty_message () {
  echo -e "Option ${BOLD}-${1:-$OPTARG}${NC} requires an argument, try 'bam --help' for more information"
}

function multi_arg_error () {
  echo -e "Invalid option combination, try 'bam --help' for more information"
  exit 1
}

function opts_message () {
  echo -e "Option ${BOLD}-${OPTARG}${NC} does not exist, try 'bam --help' for more information"
  exit 1
}

# Setting long opts to short opts
for arg in "$@"; do
  shift
  case "${arg}" in
    "--help")           set -- "$@" "-h" ;;
    "--instance-ip")    set -- "$@" "-i" ;;
    "--instance-info")  set -- "$@" "-I" ;;
    "--instance-type")  set -- "$@" "-t" ;;
    "--asg-count")      set -- "$@" "-a" ;;
    "--asg-info")       set -- "$@" "-A" ;;
    "--s3-size")        set -- "$@" "-b" ;;
    "--ssh")            set -- "$@" "-s" ;;
    "--scp")            set -- "$@" "-S" ;;
    "--output")         set -- "$@" "-o" ;;
    *)                  set -- "$@" "${arg}"
  esac
done

# Default variables
o="json"
t="*"
OPTIND=1

# Short opts
optspec=":a:A:b:i:t:I:d:s:S:o:h"
while getopts "${optspec}" opts; do
  case "${opts}" in
    a)
      a="${OPTARG}"
      empty_args "${OPTARG}" "${opts}"
      ;;
    A)
      A="${OPTARG}"
      empty_args "${OPTARG}" "${opts}"
      ;;
    i)
      i="${OPTARG}"
      empty_args "${OPTARG}" "${opts}"
      ;;
    I)
      I="${OPTARG}"
      empty_args "${OPTARG}" "${opts}"
      ;;
    b)
      b="${OPTARG}"
      empty_args "${OPTARG}" "${opts}"
      ;;
    s)
      [ "${S}" ] && multi_arg_error
      s="${OPTARG}"
      empty_args "${OPTARG}" "${opts}"
      ;;
    S)
      [ "${s}" ] && multi_arg_error
      S+=("${OPTARG}")
      empty_args "${OPTARG}" "${opts}"
      ;;
    o) 
      o="${OPTARG}"
      ;;
    t) 
      t="${OPTARG}"
      ;;
    h)
      echo -e "${aws_usage}"
      exit 1
      ;;
    :)
      empty_message
      exit 2
      ;;
    *)
      opts_message
  esac
done
shift $(expr "${OPTIND}" - 1)

# Check script for args and exit if null
if [ "${OPTIND}" -eq 1 ]; then
  echo "bam: try 'bam --help' for more information"
  exit 1
fi

# Get instance ips
if [ "${i}" ]; then
  get_instance_ips "${i}" "${o}"
fi

# Get instance info
if [ "${I}" ]; then
  get_instance_info "${I}" "${o}" "${t}"
fi

# Get instance info
if [ "${a}" ]; then
  get_asg_info "${a}" "${o}"
fi

# Get instance info
if [ "${A}" ]; then
  get_asg_info "${A}" "${o}"
fi

# Get instance info
if [ "${b}" ]; then
  get_bucket_size "${b}" "${o}"
fi

# SSH mode
if [ "${s}" ]; then
  ip_array=( $(get_instance_info "${s}" "text" "${t}" | sort -n | awk '{print $2}') )
  name_array=( $(get_instance_info "${s}" "text" "${t}" | sort -n | awk '{print $5}') )
  ip_len=$(element_length ${ip_array[@]})
  name_len=$(element_length ${name_array[@]})
  select_ssh_scp "${s}" "${t}"
fi

# SCP mode
if [ "${S}" ]; then
  ip_array=( $(get_instance_info "${S[0]}" "text" "${t}" | sort -n | awk '{print $2}') )
  name_array=( $(get_instance_info "${S[0]}" "text" "${t}" | sort -n | awk '{print $5}') )
  ip_len=$(element_length ${ip_array[@]})
  name_len=$(element_length ${name_array[@]})
  select_ssh_scp "${S[0]}" "${t}" "${S[1]}" "${S[2]}"
fi
